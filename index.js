var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{xH:()=>q,Ly:()=>K,TY:()=>J});class n extends Error{details;constructor(e,t,r={}){super(e),this.name=n.name,this.details={...r,errorCode:t}}}class r extends n{constructor(e,t){super(e,"state-mismatch-error",t),this.name=r.name}}class o extends n{constructor(e,t){super(e,"sync-callback-error",t),this.name=o.name}}function a(e){const t={beforeRender:e.beforeRender||(()=>{}),beforeRedraw:e.beforeRedraw||(()=>{}),afterRender:e.afterRender||(()=>{}),beforeDestroy:e.beforeDestroy||(()=>{})};a.tagUse.push(t)}a.tagUse=[],a.memory={},a.memory.stateConfig={array:[]};const s=e=>function(e){const t=e.memory.state,n=a.memory.stateConfig;n.rearray&&function(e,t,n){const o=e.templater?.wrapper,a=t.tagSupport?.templater.wrapper,s="last state not cleared. Possibly in the middle of rendering one component and another is trying to render";if(a)throw console.error(s,{config:t,tagFunction:o.original,wasInMiddleOf:a.original,state:n,expectedClearArray:t.rearray}),new r(s,{config:t,tagFunction:o.original,state:n,expectedClearArray:t.rearray})}(e,n,t),n.rearray=[],t?.length&&(t.forEach((e=>i(e))),n.rearray.push(...t)),n.tagSupport=e}(e);function i(e){const t=e.callback;if(!t)return e.defaultValue;const n=t(c),[r]=n,[o]=t(r);if(o!==c){const a='State property not used correctly. Second item in array is not setting value as expected.\n\nFor "let" state use `let name = state(default)(x => [name, name = x])`\n\nFor "const" state use `const name = state(default)()`\n\nProblem state:\n'+(t?t.toString():JSON.stringify(e))+"\n";throw console.error(a,{state:e,callback:t,oldState:n,oldValue:r,checkValue:o}),new Error(a)}return r}a({beforeRender:s,beforeRedraw:s,afterRender:e=>{const t=e.memory,n=a.memory.stateConfig,o=n.rearray;if(o.length&&o.length!==n.array.length){const t=`States lengths has changed ${o.length} !== ${n.array.length}. Typically occurs when a function is intended to be wrapped with a tag() call`,a=e.templater?.wrapper,s={oldStates:n.array,newStates:n.rearray,tagFunction:a.original},i=new r(t,s);throw console.warn(t,s),i}delete n.rearray,delete n.tagSupport,t.state=n.array,t.state.forEach((e=>e.lastValue=i(e))),n.array=[]}});class c{}function l(e){return u(e,new WeakMap)}function u(e,t){if(null===e||"object"!=typeof e)return e;if(t.has(e))return t.get(e);if(e instanceof Date)return new Date(e);if(e instanceof RegExp)return new RegExp(e);const n=Array.isArray(e)?[]:Object.create(Object.getPrototypeOf(e));if(t.set(e,n),Array.isArray(e))for(let r=0;r<e.length;r++)n[r]=u(e[r],t);else for(const r in e)e.hasOwnProperty(r)&&(n[r]=u(e[r],t));return n}function p(e,t){return g(e,t,new WeakMap)}function g(e,t,n){return!!(e===t||(r=e,o=t,r instanceof Function&&o instanceof Function&&r.toString()===o.toString()))||!!n.has(e)||"object"==typeof e&&"object"==typeof t&&(e instanceof Date&&t instanceof Date?e.getTime()===t.getTime():(n.set(e,0),Array.isArray(e)&&Array.isArray(t)?function(e,t,n){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(!g(e[r],t[r],n))return!1;return!0}(e,t,n):!Array.isArray(e)&&!Array.isArray(t)&&function(e,t,n){const r=Object.keys(e),o=Object.keys(t);if(0===r.length&&0===o.length)return!0;if(r.length!==o.length)return!1;for(const a of r)if(!o.includes(a)||!g(e[a],t[a],n))return!1;return!0}(e,t,n)));var r,o}function d(e,t){const n=a.memory.providerConfig;n.ownerSupport=t,e.global.providers.length&&(n.providers.length=0,n.providers.push(...e.global.providers))}function f(e){e.global.providers.filter((e=>!p(e.instance,e.clone))).forEach((t=>{!function(e,t){b(e,t).forEach((({tagSupport:e,renderCount:t,provider:n})=>{e.global.deleted||t===e.global.renderCount&&(n.clone=l(n.instance),A(e,!1))}))}(e.getAppElement(),t),t.clone=l(t.instance)}))}function b(e,t,n=[]){const r=e.global,o=r.providers.find((e=>e.constructMethod===t.constructMethod));return o&&n.push({tagSupport:e,renderCount:r.renderCount,provider:o}),e.childTags.forEach((e=>b(e,t,n))),n}function m(e,t){const n=e.templater,r=t.templater,o=n?.tag||e,a=r.tag,s=o.strings,i=t.strings||a.strings;if(s.length!==i.length)return!1;if(!s.every(((e,t)=>i[t]===e)))return!1;const c=e.values||o.values,l=t.values||a.values;return c.length===l.length&&!!l.every(((e,t)=>{const n=c[t];return!(e instanceof Function&&n instanceof Function)||!(e.toString()!==n.toString())}))}a.memory.providerConfig={providers:[],ownerSupport:void 0},a({beforeRender:(e,t)=>{d(e,t)},beforeRedraw:(e,t)=>{d(e,t.ownerTagSupport)},afterRender:e=>{const t=a.memory.providerConfig;e.global.providers=[...t.providers],t.providers.length=0}});class h{value;onSubscription;methods=[];isSubject=!0;subscribers=[];subscribeWith;constructor(e,t){this.value=e,this.onSubscription=t}subscribe(e){const t=function(e,t){const n=w.globalSubCount$;w.globalSubCount$.set(n.value+1);const r=()=>{r.unsubscribe()};return r.callback=t,r.subscriptions=[],r.unsubscribe=()=>(y(e.subscribers,t),y(w.globalSubs,t),w.globalSubCount$.set(n.value-1),r.unsubscribe=()=>r,r.subscriptions.forEach((e=>e.unsubscribe())),r),r.add=e=>(r.subscriptions.push(e),r),r.next=e=>{t(e,r)},r}(this,e),n=this.subscribeWith;if(n){if(this.methods.length){const n=e;e=e=>{v(e,this.methods,(e=>n(e,t)))}}return n(e)}return this.subscribers.push(t),w.globalSubs.push(t),this.onSubscription&&this.onSubscription(t),t}set(e){this.value=e,this.subscribers.forEach((t=>{t.callback(e,t)}))}next=this.set;toPromise(){return new Promise(((e,t)=>{this.subscribe(((t,n)=>{n.unsubscribe(),e(t)}))}))}toCallback(e){return this.subscribe(((t,n)=>{n.unsubscribe(),e(t)})),this}pipe(...e){const t=new h;return t.methods=e,t.subscribeWith=e=>this.subscribe(e),t}}function y(e,t){const n=e.findIndex((e=>e.callback===t));-1!==n&&e.splice(n,1)}const w=h;function v(e,t,n){const r=[...t],o=r.shift(),a=e=>{if(r.length)return v(e,r,n);n(e)};let s=a;const i=o(e,{setHandler:e=>s=e,next:a});s(i)}w.globalSubs=[],w.globalSubCount$=new h,w.globalSubCount$.set(0);class C extends h{value;constructor(e){super(e),this.value=e}subscribe(e){const t=super.subscribe(e);return e(this.value,t),t}}function S(e,t){a.tagUse.forEach((n=>n.beforeRender(e,t)))}function E(e,t){a.tagUse.forEach((n=>n.afterRender(e,t))),a.memory.tagClosed$.next(t)}function A(e,t){const n=e.global,r=e.templater;if(!r.wrapper){const t=e.ownerTagSupport;return++n.renderCount,A(t,!0)}const o=e.subject;let s,i=!1;t&&e&&(s=e.ownerTagSupport,s)&&(i=!p(r.props,e.propsConfig.latestCloned));const c=function(e,t,n,r){const o=r.tagSupport,s=o.global;t.global=s;const i=s.renderCount;f(e);const c=s.newest;if(i!==s.renderCount)return e.updateBy(c),c;const l=function(e,t,n,r){const o=e.global.renderCount;!function(e,t,n){const r=n?.ownerTagSupport,o=r||t;if(n){const t=n.memory.state;e.memory.state=[...t],e.global=n.global,function(e,t){a.tagUse.forEach((n=>n.beforeRedraw(e,t)))}(e,n)}else S(e,o),a.memory.providerConfig.ownerSupport=o}(e,r,t);const s=(0,e.templater.wrapper)(e,n);if(E(e,s),s.global.renderCount>o+1)return e.global.newest;e.global.newest=s,!t||m(t,s)||function(e,t,n){const r=e.global,o=r.insertBefore;var a;(a=e).global.oldest.destroy(),function(e){delete e.global.oldest,delete e.global.newest}(a),a.global.context={},t.global={...r};const s=t.global;s.insertBefore=o,s.deleted=!1,delete s.oldest,delete s.newest,delete n.tagSupport}(t,s,n);const i=t?.ownerTagSupport;return s.ownerTagSupport=r||i,s}(t,c||o||s.oldest,r,n),u=s.oldest||e;return l.global.oldest=u,m(c,l)&&(r.tagSupport=l,u.updateBy(l)),l}(e.global.oldest,e,s,o);return s&&i?(A(s,!0),c):c}a.memory.tagClosed$=new h(void 0,(e=>{a.memory.stateConfig.tagSupport||e.next()}));let x=e=>(e,t,n,r,a,s)=>{throw new o("Callback function was called immediately in sync and must instead be call async")};const R=x;function T(e,t){e.forEach(((e,n)=>{const r=i(e),o=t[n].callback;o&&o(r),t[n].lastValue=r}))}function k(e){const t=a.memory.stateConfig.array;x=n=>(...r)=>function(e,t,n,...r){const o=e.memory.state;T(o,n);const a=t(...r);T(n,o),A(e,!1),a instanceof Promise&&a.finally((()=>{T(n,o),A(e,!1)}))}(e,n,t,...r)}function O(e){a.memory.currentSupport=e}function j(e){a.memory.destroyCurrentSupport=e}a({beforeRender:e=>k(e),beforeRedraw:e=>k(e),afterRender:e=>{x=R}}),a({beforeRender:e=>O(e),beforeRedraw:e=>O(e)}),a({beforeRender:e=>j(e),beforeRedraw:e=>j(e),beforeDestroy:e=>{const t=e.global.destroyCallback;t&&t()}});const $="__tagvar";function F(e){const t=e;return!0===t?.isTemplater&&void 0===t.wrapper}function M(e){const t=e;return!0===t?.isTagClass}function _(e){return e.map((e=>{const t=e;return function(e){return e?.wrapper?.original instanceof Function}(e)?l(e.props):M(t)||F(t)?_(t.values):function(e){return e instanceof Array&&e.every((e=>M(e)||F(e)))}(t)?_(t):l(e)}))}var N;new RegExp("--"+$+"--","g"),function(e){e.tag="tag",e.templater="templater",e.tagArray="tag-array",e.tagComponent="tag-component",e.value="value"}(N||(N={})),new RegExp('\\s*<template interpolate end id="__tagvar(\\d{1,4})"([^>]*)></template>(\\s*)'),new RegExp($,"g");class P{templater;subject;isApp=!0;appElement;propsConfig;memory={state:[]};global={context:{},providers:[],renderCount:0,deleted:!1,subscriptions:[]};constructor(e,t){this.templater=e,this.subject=t;const n=e.children.value,r=e.props,o=l(r);this.propsConfig={latest:r,latestCloned:o,lastClonedKidValues:n.map((e=>_(e.values)))},F(r)||M(r)||(this.propsConfig.latestCloned=l(o))}}const D=[];function U(e,t){const n=t.getAttribute("props");if(n){const r=t.gateway,o=(I[e]||r.tagGateway).propMemory[n];return B(t,o.props),o}const r=t.getAttribute("propsJson");if(r){const e=JSON.parse(r);return B(t,e),{props:e,callCount:0}}const o=t.getAttributeNames().reduce(((e,n)=>{const r=n.split(":");let o=t.getAttribute(n);return r.length>1&&("number"===r[1]&&(o=Number(o)),n=r[0]),e[n]=o,e}),{});return delete o.tag,B(t,o),{props:o,callCount:0}}function B(e,t){const n=e.getAttribute("events");n&&n.split(",").map((e=>e.trim())).map((e=>{t[e]=t=>r(e,{detail:{[e]:t}})}));const r=function(t,n){const r=new CustomEvent(t,n);e.dispatchEvent(r)};return t}const I={},J=function(e){const t=G(e);if(I[t])return I[t];let n,r=0;function o(){const r=function(e,t){return function(e,t,n){return t.forEach((t=>H(e,t,n))),t}(e,document.querySelectorAll(`[tag="${e}"]`),t)}(t,e);return r.length?(n&&clearInterval(n),delete I[t],r.length):r.length}const s={id:t,propMemory:{},props:(e,t)=>{const n=s.propMemory[e]=s.propMemory[e]||{props:[t],callCount:0};n.props=[t],++n.callCount;const{element:r,tag:o}=n;return r&&o&&s.updateTag(o,r),e},updateTag:(e,n)=>{!function(e,t,n){n.templater;const r=n.global.newest,o=r.propsConfig.latestCloned,s=[U(e,t).props];JSON.stringify(o)!==JSON.stringify(s)&&(r.templater.props=s,a.memory.tagClosed$.toCallback((()=>{const e=n.global.newest;e.templater.props=s,A(e,!1)})))}(t,n,e)}};return o()?s:(n=setInterval((()=>{if(r+=5,r>=2e3)throw clearInterval(n),new Error(`TaggedJs Element ${t} not found`);o()}),5),I[t]=s,I[t])},V={};function W(e){const{id:t,observer:n,tag:r}=e;n.disconnect(),r.destroy(),delete V[t]}function G(e){return"__tagTemplate_"+function(e){let t=e.toString().replace(/\s+/g,"_").replace(/[^\w\d]/g,"_");return/^[a-zA-Z]/.test(t)||(t="fn_"+t),t}(e.original||e)}function H(e,t,n){const r=t.gateway;if(r)return r.updateTag(),r;const o=U(e,t),a=o.props;try{const{tagSupport:r}=function(e,t,n){const r=D.findIndex((e=>e.element===t));r>=0&&(D[r].tagSupport.destroy(),D.splice(r,1),console.warn("Found and destroyed app element already rendered to element",{element:t}));const o=function(e){let t={};const n=new C(t);t=new P(e,n),n.set(e),n.tagSupport=t,S(t,void 0);const r=(0,e.wrapper)(t,n);return E(t,r),r}(e(n));o.appElement=t,o.isApp=!0,o.global.isApp=!0;const a=document.createElement("template");return a.setAttribute("id","app-tag-"+D.length),a.setAttribute("app-tag-detail",D.length.toString()),t.appendChild(a),t.destroy=async()=>{await o.destroy();const e=o.global.insertBefore;e.parentNode.removeChild(e)},o.buildBeforeElement(a),o.global.oldest=o,o.global.newest=o,t.setUse=e.original.setUse,D.push({element:t,tagSupport:o}),{tagSupport:o,tags:e.original.tags}}(n,t,a);return o.element=t,o.tag=r,function(e,t,n,r){const o=I[e],a=new MutationObserver((e=>{if(function(e){const{element:t}=e;return!!document.body.contains(t)||(W(e),!1)}(i))for(const t of e)"attributes"===t.type&&s()}));function s(){o.updateTag(n,t)}K(r);const i={id:e,tag:n,observer:a,component:r,element:t,updateTag:s,tagGateway:o};return V[e]=V[e]||[],V[e].gates.push(i),t.gateway=i,a.observe(t,{attributes:!0}),i}(e,t,r,n)}catch(e){throw console.warn("Failed to render component to element",{component:n,element:t,props:a,err:e}),e}}class L extends HTMLElement{gateway;constructor(){super(),setTimeout((()=>this.gateway=function(e){const t=e.gateway;let n=t?.id||e.getAttribute("tag");if(!n){const t='Tagged gateway element must have a "tag" attribute which describes which tag to use';throw console.warn(t,{element:e}),new Error(t)}if(!n){const t="Cannot check a tag on element with no id attribute";throw console.warn(t,{tagName:n,element:e}),new Error(t)}const r=V[n].tagComponent;if(!r){const t=`Cannot find a tag registered by id of ${n}`;throw console.warn(t,{tagName:n,element:e}),new Error(t)}return H(n,e,r)}(this)),0)}disconnectedCallback(){W(this.gateway)}}const Y="tag-element";function q(){customElements.define(Y,L)}let z=!1;function K(e){if(!z){try{q()}catch(e){throw e}z=!0}const t=G(e);return V[t]=V[t]||{gates:[],tagComponent:e},V[t].tagComponent=e,t}var Z=t.xH,Q=t.Ly,X=t.TY;export{Z as initWebComponents,Q as loadTagGateway,X as tagGateway};