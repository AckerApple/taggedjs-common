var e={519:e=>{function t(e){return Promise.resolve().then((()=>{return import(e);throw t.code="MODULE_NOT_FOUND",t}))}t.keys=()=>[],t.resolve=t,t.id=519,e.exports=t}},t={};function o(n){var r=t[n];if(void 0!==r)return r.exports;var a=t[n]={exports:{}};return e[n](a,a.exports,o),a.exports}o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{function e(e){[...document.querySelectorAll("app")].forEach(e)}async function t(){const e=[...document.querySelectorAll("[tag]")].map((async e=>{const t=e.getAttribute("url"),n=e.getAttribute("name");console.log(`loading tagName ${n}...`);const r=await o(519)(`${t}?${Date.now()}`);try{const e=r[n]();return{newApp:r,newTemplater:e,tagName:n}}catch(e){throw console.error(`Could not load tag by name ${n}`,{newApp:r,url:t}),e}}));return await Promise.all(e)}!function o(){const c=new WebSocket("ws://localhost:3000");c.addEventListener("error",(e=>{console.error("WebSocket error:",e)})),c.addEventListener("open",(e=>{console.info("WebSocket connection opened:",e)})),c.addEventListener("message",(async o=>{console.info("Message from server:",o.data,o.data),"Connected to the WebSocket endpoint"!==o.data?e((e=>{!async function(e){console.log("updateByElement *********");const o=r,c=e.setUse;(await t()).forEach((async e=>{const{newApp:t,newTemplater:i}=e,{redrawTag:l}=t.hmr,g=i.wrapper.original.tags,p=i.wrapper.original.setUse;c.tagUse=p.tagUse,Object.assign(c.memory,p.memory),p.memory=c.memory;const d=o.reduce(((e,t)=>{const o=g.find((e=>e.toString()===t.toString()));return o||e.push({oldTag:t,newTag:o}),e}),[]);d||console.warn("No old tags changed");const w=o.length===g.length;if(g.forEach((e=>{let t=o.find((t=>e.toString()===t.toString())),n=null;if(!t&&d[0].newTag&&(n=e.tagIndex,w&&o[n].length===e.length&&(t=o[n])),!t){if(d[0].newTag){const t="HMR has two tags";throw console.warn(t,{first:d[0].newTag,second:e,equal:e===d[0].newTag,oldTags:o,newTags:g,tagIndex:n}),new Error(t)}d[0].newTag=e}})),d.length){const e=d[0].oldTag,t=n.tagSupport.templater,o=t.wrapper.original===e,c=t.wrapper.original.toString()===e.toString();if(o||c){const e=d[0].newTag;return n.tagSupport.templater.wrapper.original=e,await n.destroy(),n=await a(n),void(r=g)}const i=await s(n,d[0],l);i<=0?console.warn("✋ No components were updated",d[0]):console.debug(`✅ Replaced and update components ${i}`,d[0])}r=g,console.info("✅ ✅ ✅ rebuilt")}))}(e)})):e((e=>{t().then((t=>{t.forEach((({newApp:t,tagName:o})=>{console.log(111,t.hmr);const{tagElement:a}=t.hmr,s=a(t[o],e,{test:1});return r=s.tags,n=s.tag,s}))}))}))})),c.addEventListener("close",(e=>{console.info("WebSocket connection closed:",e),o()}))}();let n,r=[];async function a(e,t){const{retag:o}=t(e.tagSupport,e.tagSupport.templater,e);return o.insertBefore=e.insertBefore,o.rebuild(),e.ownerTag&&o.ownerTag.children.push(o),o}async function s(e,{oldTag:t,newTag:o},n){let r=0;const i=e.values.map((async(n,s)=>{if(!n||!n.isTemplater)return;const i=n.wrapper.original===t,l=n.wrapper.original.toString()===t.toString();if(i||l){const t=e.tagSupport.memory.context[`__tagVar${s}`];return n.wrapper.original=o,t?.tag?(t.tag.tagSupport.templater.wrapper.original=o,await t.tag.destroy(),c(t.tag.tagSupport.memory.context),t.tag=await a(t.tag),void++r):void console.warn("potential hmr issue here")}}));await Promise.all(i);const l=e.children.map((async e=>{r+=await s(e,{oldTag:t,newTag:o},n)}));return await Promise.all(l),r}function c(e){Object.values(e).forEach((e=>{e.clone&&delete e.clone,e.tag&&c(e.tag.tagSupport.memory.context)}))}})();